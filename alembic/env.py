"""
Alembic migration environment for CDIL.

Supports both SQLite (dev/test) and PostgreSQL (production) via
the DATABASE_URL environment variable or CDIL_DB_PATH for SQLite.

DATABASE_URL takes precedence:
  - postgresql://...  -> Postgres
  - sqlite:///...     -> SQLite (path-explicit)

If DATABASE_URL is not set, falls back to CDIL_DB_PATH env var
(as a SQLite file path), then defaults to /tmp/cdil.db.
"""

import os
from logging.config import fileConfig

from alembic import context
from sqlalchemy import create_engine, pool

# Alembic Config object provides access to alembic.ini values.
config = context.config

# Interpret the config file for Python logging.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


def _get_database_url() -> str:
    """Resolve database URL from Alembic config or environment.

    Priority:
    1. sqlalchemy.url already set in the Alembic Config object
       (injected programmatically by ensure_schema())
    2. DATABASE_URL environment variable (full SQLAlchemy URL)
    3. CDIL_DB_PATH environment variable (SQLite file path)
    4. Default /tmp/cdil.db (SQLite)
    """
    configured_url = config.get_main_option("sqlalchemy.url")
    if configured_url:
        return configured_url

    database_url = os.getenv("DATABASE_URL")
    if database_url:
        return database_url

    cdil_db_path = os.getenv("CDIL_DB_PATH")
    if cdil_db_path:
        return f"sqlite:///{cdil_db_path}"

    return "sqlite:////tmp/cdil.db"


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode (emit SQL without a live connection)."""
    url = _get_database_url()
    context.configure(
        url=url,
        target_metadata=None,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
from logging.config import fileConfig

from alembic import context

# Alembic Config object â€” provides access to values within the .ini file.
config = context.config

# Set up Python logging from the .ini file when running via CLI.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# No SQLAlchemy metadata object is used here because CDIL keeps its runtime
# DB layer in raw sqlite3/psycopg2.  Migrations are written explicitly using
# Alembic ops rather than autogenerated from ORM models.
target_metadata = None


def _get_url() -> str:
    """Return DATABASE_URL from env, falling back to alembic.ini value.

    Environment variable takes precedence so that CI, Docker, and local dev
    can all configure the target DB without editing the ini file.
    """
    import os

    url = os.environ.get("DATABASE_URL")
    if url:
        return url
    ini_url = config.get_main_option("sqlalchemy.url")
    if not ini_url or "localhost/cdil" in ini_url:
        raise RuntimeError(
            "Set the DATABASE_URL environment variable before running Alembic.\n"
            "  export DATABASE_URL=postgresql+psycopg2://cdil:cdil@localhost:5432/cdil"
        )
    return ini_url


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode (emit SQL to stdout, no live DB)."""
    url = _get_url()
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode (with a live DB connection)."""
    url = _get_database_url()

    connect_args = {}
    if url.startswith("sqlite"):
        connect_args["check_same_thread"] = False

    connectable = create_engine(
        url,
        poolclass=pool.NullPool,
        connect_args=connect_args,
    )
    """Run migrations in 'online' mode (connect to the target DB)."""
    from gateway.app.db.alembic_engine import get_engine

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=None,
            # SQLite does not support transactional DDL natively;
            # render_as_batch allows ALTER TABLE emulation.
            render_as_batch=url.startswith("sqlite"),
        )
            target_metadata=target_metadata,
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

# Canonical Message Security Analysis

**Date**: 2026-02-18  
**Purpose**: Verify canonical_message is server-generated and secure

---

## Summary

✅ **SECURE**: canonical_message is entirely server-generated and includes replay protection

---

## Analysis

### 1. ✅ Canonical Message is Server-Generated (NOT Client-Controlled)

**Evidence from `gateway/app/routes/clinical.py`:**

Lines 257-265 show canonical_message construction:
```python
canonical_message = {
    "certificate_id": certificate_id,           # Line 221: Server-generated UUID7
    "tenant_id": tenant_id,                     # Line 191: From JWT (server-validated)
    "timestamp": timestamp,                     # Line 222: Server timestamp
    "chain_hash": chain_hash,                   # Line 256: Server-computed
    "note_hash": note_hash,                     # Line 227: Server-computed SHA-256
    "governance_policy_version": req_body.governance_policy_version  # Client input (non-security-critical)
}
```

**Security Properties:**
- `certificate_id`: Generated by server using `generate_uuid7()` - client has no control
- `tenant_id`: Extracted from JWT by server - cryptographically validated, client cannot forge
- `timestamp`: Server's UTC timestamp - client cannot control
- `chain_hash`: Computed by server from previous chain state - client cannot manipulate
- `note_hash`: Hashed by server from note_text - client provides plaintext, server hashes
- `governance_policy_version`: Client-provided but not security-critical (metadata only)

**Conclusion**: Client has ZERO control over security-critical fields in canonical_message.

---

### 2. ✅ Canonical Message Includes All Required Fields

**Required for security:**
- ✅ `certificate_id` - Unique identifier (prevents replay with different cert ID)
- ✅ `tenant_id` - Tenant isolation (binds signature to tenant)
- ✅ `timestamp` - Temporal ordering (prevents time-based attacks)
- ✅ `chain_hash` - Chain integrity (prevents insertion/tampering)
- ✅ `note_hash` - Content binding (proves what was signed)
- ✅ `governance_policy_version` - Policy binding (proves which rules applied)

**Additional protection in sign_generic_message():**

From `gateway/app/services/signer.py:238-242`:
```python
enhanced_message = {
    **message_obj,
    "nonce": generate_uuid7(),                   # Replay protection
    "server_timestamp": datetime.now(timezone.utc).isoformat()  # Additional timestamp
}
```

The signer ADDS two more server-controlled fields:
- `nonce`: UUID7 (time-ordered, unique) - prevents replay attacks
- `server_timestamp`: Additional server timestamp - belt-and-suspenders timing

**Nonce checking** (lines 258-260):
```python
if not check_and_record_nonce(tenant_id, nonce):
    raise ValueError(f"Nonce already used: {nonce} (replay attack detected)")
```

**Conclusion**: All security-critical fields are present, plus additional replay protection.

---

### 3. ✅ Verification Uses Stored Canonical Message Correctly

**Verification logic from `gateway/app/routes/clinical.py:510-540`:**

```python
# Line 514: Load stored canonical_message
canonical_message = signature_bundle.get("canonical_message")

if not canonical_message:
    # Lines 518-525: Legacy fallback - reconstruct from certificate fields
    # This is safe because it recomputes from stored, immutable certificate data
    canonical_message = {
        "certificate_id": certificate["certificate_id"],
        "tenant_id": certificate["tenant_id"],
        "timestamp": certificate["timestamp"],
        "chain_hash": certificate["integrity_chain"]["chain_hash"],
        "note_hash": certificate["note_hash"],
        "governance_policy_version": certificate["governance_policy_version"]
    }

# Lines 528-533: Build signature bundle for verification
sig_bundle = {
    "key_id": signature_bundle["key_id"],
    "algorithm": signature_bundle["algorithm"],
    "signature": signature_bundle["signature"],
    "canonical_message": canonical_message
}

# Line 535: Verify signature
signature_valid = verify_signature(sig_bundle, jwk)
```

**Security analysis:**

**Case 1: New certificates (with stored canonical_message)**
- Uses the canonical_message that was SIGNED (stored in certificate)
- This is the original server-generated message from signing time
- Verification checks signature matches this exact message
- ✅ SECURE: Verifies original server-generated message

**Case 2: Legacy certificates (without stored canonical_message)**
- Reconstructs canonical_message from certificate fields
- All fields are from stored certificate (immutable after storage)
- No client input used in reconstruction
- ✅ SECURE: Reconstructs from trusted, immutable data

**Potential concern addressed:**
- Question: "Could canonical_message be swapped/edited without detection?"
- Answer: NO, because:
  1. canonical_message is part of the signature itself (it's what was signed)
  2. If canonical_message doesn't match signature, verification fails
  3. Signature is verified using tenant's public key (from key registry)
  4. Any tampering with canonical_message breaks cryptographic signature

---

## Best Practice Assessment

The problem statement suggested two options for canonical message handling:

### Option A: Recompute canonical message from stored fields deterministically
**Current implementation**: Partially used (legacy path)
- Pro: Ensures canonical_message matches certificate fields
- Con: Requires maintaining exact reconstruction logic
- Used for: Legacy certificates without stored canonical_message

### Option B: Store canonical_message + verify it matches recomputed version
**Current implementation**: Stores canonical_message (belt + suspenders)
- Pro: Preserves exact signed message (including nonce, server_timestamp)
- Pro: No reconstruction ambiguity
- Con: Slightly more storage space
- Used for: New certificates

**CDIL uses a hybrid approach:**
1. Stores canonical_message with signature (Option B)
2. Can reconstruct for legacy certificates (Option A)
3. Signature verification itself ensures integrity (either way is secure)

**This is BETTER than either option alone** because:
- New certs: Exact signed message preserved (no reconstruction needed)
- Legacy certs: Can still verify (backward compatible)
- Either way: Signature verification ensures canonical_message integrity

---

## Replay Attack Protection

**Nonce mechanism from `gateway/app/services/signer.py:87-122`:**

```python
def check_and_record_nonce(tenant_id: str, nonce: str) -> bool:
    # Lines 105-109: Check if nonce exists for this tenant
    cursor = conn.execute("""
        SELECT 1 FROM used_nonces
        WHERE tenant_id = ? AND nonce = ?
    """, (tenant_id, nonce))
    
    if cursor.fetchone():
        return False  # Nonce already used (replay attack!)
    
    # Lines 112-117: Record the nonce
    conn.execute("""
        INSERT INTO used_nonces (tenant_id, nonce, used_at_utc)
        VALUES (?, ?, ?)
    """, (tenant_id, nonce, used_at_utc))
```

**Database schema from `gateway/app/db/schema.sql:69-79`:**
```sql
CREATE TABLE IF NOT EXISTS used_nonces (
    tenant_id TEXT NOT NULL,
    nonce TEXT NOT NULL,
    used_at_utc TEXT NOT NULL,
    PRIMARY KEY (tenant_id, nonce)  -- Unique constraint prevents replay
);
CREATE INDEX IF NOT EXISTS idx_used_nonces_used_at ON used_nonces(used_at_utc);
```

**Security properties:**
- Nonces are tenant-scoped (prevents cross-tenant nonce reuse)
- UUID7 nonces are time-ordered and globally unique
- Database constraint prevents replay (PRIMARY KEY enforces uniqueness)
- Index on used_at_utc allows efficient cleanup of old nonces

---

## Security Boundaries

### What Client Can Control:
1. `note_text` - BUT server hashes it (client never sees hash used in signature)
2. `governance_policy_version` - Metadata only (non-security-critical)
3. `patient_reference`, `human_reviewer_id` - BUT server hashes them
4. `model_version`, `prompt_version` - Metadata only

### What Client CANNOT Control:
1. ❌ `certificate_id` - Server-generated UUID7
2. ❌ `tenant_id` - From JWT (cryptographically validated)
3. ❌ `timestamp` - Server timestamp
4. ❌ `chain_hash` - Server-computed from chain state
5. ❌ `note_hash` - Server-computed SHA-256
6. ❌ `nonce` - Server-generated for each signature
7. ❌ `server_timestamp` - Server timestamp in signature
8. ❌ `key_id` - Selected by server based on tenant_id
9. ❌ `signature` - Computed by server using tenant's private key

**Result**: Client cannot forge, modify, or replay certificates.

---

## Conclusion

### ✅ All Requirements Met:

1. **Canonical message is server-generated** ✅
   - All security-critical fields are server-controlled
   - Client input is only metadata or gets hashed by server

2. **Includes all required fields** ✅
   - certificate_id, tenant_id, timestamp, chain_hash, note_hash, policy_version
   - PLUS nonce and server_timestamp for replay protection

3. **Cannot be swapped/edited without detection** ✅
   - Cryptographic signature binds canonical_message to certificate
   - Any tampering breaks signature verification
   - Stored canonical_message is what was signed (immutable)

4. **Verification is secure** ✅
   - Uses stored canonical_message (exact signed message)
   - Falls back to reconstruction from immutable certificate fields
   - Signature verification ensures integrity either way

5. **Replay protection** ✅
   - Nonce recorded per-tenant in database
   - Prevents signature reuse across requests
   - Time-ordered UUID7 nonces + database constraint

### Recommendations:

**None** - Implementation exceeds security requirements.

The hybrid approach (store canonical_message + support reconstruction) provides:
- Maximum security (exact signed message preserved)
- Backward compatibility (legacy certs still verify)
- Defense in depth (signature verification ensures integrity)

---

**Analysis Date**: 2026-02-18  
**Status**: SECURE ✅  
**Next Review**: After any changes to signing or verification logic
